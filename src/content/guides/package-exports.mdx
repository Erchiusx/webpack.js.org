---
title: Package exports
sort: 25
contributors:
  - sokra
  - Erchiusx
related:
  - title: Package entry points in Node.js
    url: https://nodejs.org/api/packages.html#packages_package_entry_points
---

The `exports` field in the `package.json` of a package allows to declare
which module should be used when using module requests like `import "package"` or `import "package/sub/path"`.
It replaces the default implementation that returns `main` field resp. `index.js` files for `"package"` and
the file system lookup for `"package/sub/path"`.

一个包的`package.json`文件中的`exports`键声明了
在通过类似于`import "package"`或`import "package/sub/path"`的方式请求导入模块时，它应使用哪些内容。
它将取代如下几项默认的行为：
1. 对于请求`"package"`，尝试返回包的`main`字段；如果不存在，则查询文件夹下的`index.js`；
2. 对于请求`"package/sub/path"`，对其进行进一步的文件系统查询。

当`exports`字段存在时，只能请求这些被声明的模块。
任何其它模块查询请求均会导致`ModuleNotFound`错误。

## 语法概述

一般而言，`exports`属性应当包含一个对象，
其每一个字段声明了一个对应于模块请求的子路径。
对于以上的例子，应当使用这些键：
1. 用`"."`键声明`import "package"`的结果；
2. 用`"./sub/path"`键声明`import "package/sub/path"`的结果。
以`/`结尾的属性值将会使请求被转发为一个以此路径为前缀的，使用旧有的文件系统查询算法的请求。
对于以`*`结尾的键，`*`能取任何值，且对应的属性值中的`*`会被相应地替换。

示例如下：

```json
{
  "exports": {
    ".": "./main.js",
    "./sub/path": "./secondary.js",
    "./prefix/": "./directory/",
    "./prefix/deep/": "./other-directory/",
    "./other-prefix/*": "./yet-another/*/*.js"
  }
}
```

| 请求                                | 结果                                             |
| ----------------------------------- | ------------------------------------------------ |
| `package`                           | `.../package/main.js`                            |
| `package/sub/path`                  | `.../package/secondary.js`                       |
| `package/prefix/some/file.js`       | `.../package/directory/some/file.js`             |
| `package/prefix/deep/file.js`       | `.../package/other-directory/file.js`            |
| `package/other-prefix/deep/file.js` | `.../package/yet-another/deep/file/deep/file.js` |
| `package/main.js`                   | Error                                            |

## 可选语法

除了提供单一的结果，包作者也可以提供一列结果。
在这种情况下，会依次尝试导入它们，并使用第一个有效的结果。

注：仅会使用第一个有效的结果，而非所有的。

示例如下：

```json
{
  "exports": {
    "./things/": ["./good-things/", "./bad-things/"]
  }
}
```

此时，`package/things/apple`的可能会被解析为`.../package/good-things/apple`或`.../package/bad-things/apple`.

## 有限定条件的语法

除了直接以`exports`键给出结果，
包作者还可以让模块系统基于环境的信息选择一个结果。

在这种情况下，应当使用一个对象，将条件映射为结果。
这些条件将会被按照其在映射对象中出现的顺序被依次尝试；
包含无效结果的条件会被略过；
要创建一个“和”的逻辑，应当嵌套这些条件。
特别地，最后一个条件可以是特殊的`"default"`条件，
它永远都会被匹配。

示例如下：

```json
{
  "exports": {
    ".": {
      "red": "./stop.js",
      "yellow": "./stop.js",
      "green": {
        "free": "./drive.js",
        "default": "./wait.js"
      },
      "default": "./drive-carefully.js"
    }
  }
}
```

这可以近似地被翻译为：

```ts
if (red && valid('./stop.js')) return './stop.js';
if (yellow && valid('./stop.js')) return './stop.js';
if (green) {
  if (free && valid('./drive.js')) return './drive.js';
  if (valid('./wait.js')) return './wait.js';
}
if (valid('./drive-carefully.js')) return './drive-carefully.js';
throw new ModuleNotFoundError();
```

可使用的条件高度依模块系统和工具而变化。

## 简略写法

当该包仅支持一个`"."`键时，`{".": ... }`的对象嵌套可以被省略：

```json
{
  "exports": "./index.mjs"
}
```

```json
{
  "exports": {
    "red": "./stop.js",
    "green": "./drive.js"
  }
}
```

## 关于顺序的附注

在每一个键都是条件的对象中，属性的顺序非常重要。条件按它们的出现顺序被处理。

例如: `{ "red": "./stop.js", "green": "./drive.js" }` != `{ "green": "./drive.js", "red": "./stop.js" }` (当 `red` and `green` 均成立时, 会使用第一个出现的键)

在每一个键都是子路径时，属性（这些子路径）的出现顺序不重要。更详细的路径会比更简短的路径更优先地匹配。

例如: `{ "./a/": "./x/", "./a/b/": "./y/", "./a/b/c": "./z" }` == `{ "./a/b/c": "./z", "./a/b/": "./y/", "./a/": "./x/" }` (永远按照 `./a/b/c` > `./a/b/` > `./a/` 的顺序)

`exports` 键永远比 `main`, `module`, `browser` 和其它自定义的键更优先.

## 支持情况

| Feature                                | Supported by                                                                       |
| -------------------------------------- | ---------------------------------------------------------------------------------- |
| `"."` property                         | Node.js, webpack, rollup, esinstall, wmr                                           |
| normal property                        | Node.js, webpack, rollup, esinstall, wmr                                           |
| property ending with `/`               | Node.js<sup>(1)</sup>, webpack, rollup, esinstall<sup>(2)</sup>, wmr<sup>(3)</sup> |
| property ending with `*`               | Node.js, webpack, rollup, esinstall                                                |
| Alternatives                           | Node.js, webpack, rollup, <strike>esinstall</strike><sup>(4)</sup>                 |
| Abbreviation only path                 | Node.js, webpack, rollup, esinstall, wmr                                           |
| Abbreviation only conditions           | Node.js, webpack, rollup, esinstall, wmr                                           |
| Conditional syntax                     | Node.js, webpack, rollup, esinstall, wmr                                           |
| Nested conditional syntax              | Node.js, webpack, rollup, wmr<sup>(5)</sup>                                        |
| Conditions Order                       | Node.js, webpack, rollup, wmr<sup>(6)</sup>                                        |
| `"default"` condition                  | Node.js, webpack, rollup, esinstall, wmr                                           |
| Path Order                             | Node.js, webpack, rollup                                                           |
| Error when not mapped                  | Node.js, webpack, rollup, esinstall, wmr<sup>(7)</sup>                             |
| Error when mixing conditions and paths | Node.js, webpack, rollup                                                           |

(1) 已在 Node.js 中废弃, 优先考虑 `*`.

(2) `"./"` 这一键被有意地忽略了.

(3) 属性值被忽略了，而键被用作目标。 高效，但当且仅当键和值都互不相同时。

(4) 这一语法受到了支持，但永远仅使用第一个结果，因而不具有任何实际使用空间。

(5) 向同级和父级其它选项的回退的处理不正确。

(6) 在使用`require`时，对象的顺序没有被正确处理。这是一个有意的设计，因为在wmr中，不同的引用语法不被区分。

(7) 在使用 `"exports": "./file.js"` 变种时，任何请求（以 `package/not-existing`为例）都会被解析为那一结果（"./file.js"）。当不使用这一变种时，直接请求特定文件（例如 `package/file.js`）不会导致错误.

## 条件限定

### 引用语法

取决于引用模块的语法，这些条件之一成立：

| 条件      | 描述                                                               | 支持                                                                 |
| --------- | ----------------------------------------------------------------- | -------------------------------------------------------------------- |
| `import`  | 以ESM或相似形式请求                                                | Node.js, webpack, rollup, esinstall<sup>(1)</sup>, wmr<sup>(1)</sup> |
| `require` | 以CommonJs/AMD或相似形式请求                                       | Node.js, webpack, rollup, esinstall<sup>(1)</sup>, wmr<sup>(1)</sup> |
| `style`   | 以样式表形式请求                                                   |
| `sass`    | 以sass样式表形式请求                                               |
| `asset`   | 以资源模块形式请求                                                 |
| `script`  | 以不涉及模块系统的脚本加载方式请求                                  |

另外，这些条件之一也可能成立:

| 条件        | 描述                                                                                                                | 支持                  |
| ----------- | ------------------------------------------------------------------------------------------------------------------- | -------------------- |
| `module`    | 当所有对JavaScript的请求都支持ESM时成立<br />(只有结合使用 `import` 和 `require` 时)                                  | webpack, rollup, wmr |
| `esmodules` | 对支持ESM的工具永远成立                                                                                              | wmr                  |
| `types`     | 由typescript发起的，在乎类型的请求                                                                                   |

(1) `import` 和 `require` 依引用的语法而成立；`require`优先级总是较低。

#### import

如下语法使 `import` 条件成立:

- ESM 中的 ESM import 声明
- JS 中的 import() 表达式
- HTML 中的 <script type="module">
- HTML 中的 <link rel="preload/prefetch">
- JS 中的 new Worker(..., { type: "module" })
- WASM 中的 import 部分
- ESM HMR（webpack）中的 import.hot.accept/decline([...])
- JS 中的 Worklet.addModule
- 使用 JavaScript 作为入口点

#### require

如下语法使 `require` 条件成立:

- CommonJs `require(...)`
- AMD `define()`
- AMD `require([...])`
- CommonJs `require.resolve()`
- CommonJs (webpack) `require.ensure([...])`
- CommonJs (webpack) `require.context`
- CommonJs HMR (webpack) `module.hot.accept/decline([...])`
- HTML `<script src="...">`

#### style

如下语法使 `style` 条件成立:

- CSS `@import`
- HTML `<link rel="stylesheet">`

#### asset

如下语法使 `asset` 条件成立:

- CSS `url()`
- ESM `new URL(..., import.meta.url)`
- HTML `<img src="...">`

#### script

如下语法使 `script` 条件成立:

- HTML `<script src="...">`

`script` 应当仅在没有模块系统存在时成立。
当脚本被支持CommonJs的系统处理时，
应该为设置 `require` 成立.

这一条件仅应在寻找能作为标签直接嵌入HTML页面而不需要额外处理时设为成立。

### 优化

如下条件为了各类优化而设置:

| 条件          | 描述                                                                | 支持          |
| ------------- | ------------------------------------------------------------------- | ------------ |
| `production`  | 生产环境。<br />不应包含任何devtool                                  | webpack      |
| `development` | 开发环境。<br />应包含devtool                                        | webpack      |

注: 由于并非所有人都支持 `production` 和 `development` ，没有任何一个成立时不应做出任何相关假设。

### 目标环境

如下条件依目标环境而设置:

| 条件           | 描述                                          | 支持                                 |
| -------------- | --------------------------------------------- | ----------------------------------- |
| `browser`      | 代码会在浏览器环境中执行                       | webpack, esinstall, wmr             |
| `electron`     | 代码会在electron中执行<sup>(1)</sup>           | webpack                             |
| `worker`       | 代码会在(Web)Worker中执行<sup>(1)</sup>        | webpack                             |
| `worklet`      | 代码会在Worklet中执行<sup>(1)</sup>            |                                     |
| `node`         | 代码会证node环境中执行                         | Node.js, webpack, wmr<sup>(2)</sup> |
| `deno`         | 代码会在deno环境中执行                         |                                     |
| `react-native` | 代码会在react-native中执行                     |                                     |

(1) `electron`, `worker` 和 `worklet` 应与 `node` 或 `browser`一同出现，具体取决于上下文。

(2) 此处为浏览器支持而设置。

由于每个环境具有若干版本，应按如下规则设置条件：

- `node`: 查阅 `engines` 键以了解其支持。
- `browser`: 与包发布时间的 Spec 和 stage 4 提案一致。Polyfill或转译必须在用户端处理。
  - 无法转译或polyfill的规则应当慎用，因为它限制了可能的使用环境。
- `deno`: TBD
- `react-native`: TBD

### 预处理和运行时条件

依预处理工具，如下条件被设置：

| 条件      | 描述                   |  支持        |
| --------- | --------------------- | ------------ |
| `webpack` | Processed by webpack. | webpack      |

Sadly there is no `node-js` condition for Node.js as runtime.
This would simplify creating exceptions for Node.js.

### 自动逸条件

以下工具支持自定义条件:

| Tool      | Supported | Notes                                                                                                    |
| --------- | --------- | -------------------------------------------------------------------------------------------------------- |
| Node.js   | yes       | Use [`--conditions`](https://nodejs.org/api/cli.html#cli_c_condition_conditions_condition) CLI argument. |
| webpack   | yes       | Use [`resolve.conditionNames`](/configuration/resolve/#resolveconditionnames) configuration option.      |
| rollup    | yes       | Use `exportConditions` option for `@rollup/plugin-node-resolve`                                          |
| esinstall | no        |
| wmr       | no        |

对于自定义条件，推荐如下命名规则:

`<company-name>:<condition-name>`

示例: `example-corp:beta`, `google:internal`.

## 模式

All patterns are explained with a single `"."` entry into the package, but they can be extended from multiple entries too, by repeating the pattern for each entry.

These pattern should be used as guide not as strict ruleset.
They can be adapted to the individual packages.

These pattern are based on the following list of goals/assumptions:

- Packages are rotting.
  - We assume at some point packages are no longer being maintained, but they are continued to be used.
  - `exports` should be written to use fallbacks for unknown future cases. `default` condition can be used for that.
  - As the future is unknown we assume an environment similar to browsers and module system similar to ESM.
- Not all conditions are supported by every tool.
  - Fallbacks should be used to handled these cases.
  - We assume the following fallback make sense in general:
    - ESM > CommonJs
    - Production > Development
    - Browser > node.js

Depending on the package intention maybe something else makes sense and in this case the patterns should be adopted to that. Example: For a command line tool a browser-like future and fallback doesn't make a lot of sense, and in this case node.js-like environments and fallbacks should be used instead.

For complex use cases multiple patterns need to be combined by nesting these conditions.

### Target environment independent packages

These patterns make sense for packages that do not use environment specific APIs.

#### Providing only an ESM version

```json
{
  "type": "module",
  "exports": "./index.js"
}
```

Note: Providing only a ESM comes with restrictions for node.js.
Such a package would only work in Node.js >= 14 and only when using `import`.
It won't work with `require()`.

#### Providing CommonJs and ESM version (stateless)

```json
{
  "type": "module",
  "exports": {
    "node": {
      "module": "./index.js",
      "require": "./index.cjs"
    },
    "default": "./index.js"
  }
}
```

Most tools get the ESM version.
Node.js is an exception here.
It gets a CommonJs version when using `require()`.
This will lead to two instances of these package when referencing it with `require()` and `import`, but that doesn't hurt as the package doesn't have state.

The `module` condition is used as optimization when preprocessing node-targeted code with a tool that supports ESM for `require()` (like a bundler, when bundling for Node.js).
For such a tool the exception is skipped.
This is technically optional, but bundlers would include the package source code twice otherwise.

You can also use the stateless pattern if you are able to isolate your package state in JSON files.
JSON is consumable from CommonJs and ESM without polluting the graph with the other module system.

Note that here stateless also means class instances are not tested with `instanceof` as there can be two different classes because of the double module instantiation.

#### Providing CommonJs and ESM version (stateful)

```json
{
  "type": "module",
  "exports": {
    "node": {
      "module": "./index.js",
      "import": "./wrapper.js",
      "require": "./index.cjs"
    },
    "default": "./index.js"
  }
}
```

```js
// wrapper.js
import cjs from './index.cjs';

export const A = cjs.A;
export const B = cjs.B;
```

In a stateful package we must ensure that the package is never instantiated twice.

This isn't a problem for most tools, but Node.js is again an exception here.
For Node.js we always use the CommonJs version and expose named exports in the ESM with a ESM wrapper.

We use the `module` condition as optimization again.

#### Providing only a CommonJs version

```json
{
  "type": "commonjs",
  "exports": "./index.js"
}
```

Providing `"type": "commonjs"` helps to statically detect CommonJs files.

#### Providing a bundled script version for direct browser consumption

```json
{
  "type": "module",
  "exports": {
    "script": "./dist-bundle.js",
    "default": "./index.js"
  }
}
```

Note that despite using `"type": "module"` and `.js` for `dist-bundle.js` this file is not in ESM format.
It should use globals to allow direct consumption as script tag.

### Providing devtools or production optimizations

These patterns make sense when a package contains two versions, one for development and one for production.
E. g. the development version could include additional code for better error message or additional warnings.

#### Without Node.js runtime detection

```json
{
  "type": "module",
  "exports": {
    "development": "./index-with-devtools.js",
    "default": "./index-optimized.js"
  }
}
```

When the `development` condition is supported we use the version enhanced for development.
Otherwise, in production or when mode is unknown, we use the optimized version.

#### With Node.js runtime detection

```json
{
  "type": "module",
  "exports": {
    "development": "./index-with-devtools.js",
    "production": "./index-optimized.js",
    "node": "./wrapper-process-env.cjs",
    "default": "./index-optimized.js"
  }
}
```

```js
// wrapper-process-env.cjs
if (process.env.NODE_ENV !== 'development') {
  module.exports = require('./index-optimized.cjs');
} else {
  module.exports = require('./index-with-devtools.cjs');
}
```

We prefer static detection of production/development mode via the `production` or `development` condition.

Node.js allows to detection production/development mode at runtime via `process.env.NODE_ENV`, so we use that as fallback in Node.js. Sync conditional importing ESM is not possible and we don't want to load the package twice, so we have to use CommonJs for the runtime detection.

When it's not possible to detect mode we fallback to the production version.

### Providing different versions depending on target environment

A fallback environment should be chosen that makes sense for the package to support future environments.
In general a browser-like environment should be assumed.

#### Providing Node.js, WebWorker and browser versions

```json
{
  "type": "module",
  "exports": {
    "node": "./index-node.js",
    "worker": "./index-worker.js",
    "default": "./index.js"
  }
}
```

#### Providing Node.js, browser and electron versions

```json
{
  "type": "module",
  "exports": {
    "electron": {
      "node": "./index-electron-node.js",
      "default": "./index-electron.js"
    },
    "node": "./index-node.js",
    "default": "./index.js"
  }
}
```

### Combining patterns

#### Example 1

This is an example for a package that has optimizations for production and development usage with runtime detection for `process.env` and also ships a CommonJs and ESM version

```json
{
  "type": "module",
  "exports": {
    "node": {
      "development": {
        "module": "./index-with-devtools.js",
        "import": "./wrapper-with-devtools.js",
        "require": "./index-with-devtools.cjs"
      },
      "production": {
        "module": "./index-optimized.js",
        "import": "./wrapper-optimized.js",
        "require": "./index-optimized.cjs"
      },
      "default": "./wrapper-process-env.cjs"
    },
    "development": "./index-with-devtools.js",
    "production": "./index-optimized.js",
    "default": "./index-optimized.js"
  }
}
```

#### Example 2

This is an example for a package that supports Node.js, browser and electron, has optimizations for production and development usage with runtime detection for `process.env` and also ships a CommonJs and ESM version.

```json
{
  "type": "module",
  "exports": {
    "electron": {
      "node": {
        "development": {
          "module": "./index-electron-node-with-devtools.js",
          "import": "./wrapper-electron-node-with-devtools.js",
          "require": "./index-electron-node-with-devtools.cjs"
        },
        "production": {
          "module": "./index-electron-node-optimized.js",
          "import": "./wrapper-electron-node-optimized.js",
          "require": "./index-electron-node-optimized.cjs"
        },
        "default": "./wrapper-electron-node-process-env.cjs"
      },
      "development": "./index-electron-with-devtools.js",
      "production": "./index-electron-optimized.js",
      "default": "./index-electron-optimized.js"
    },
    "node": {
      "development": {
        "module": "./index-node-with-devtools.js",
        "import": "./wrapper-node-with-devtools.js",
        "require": "./index-node-with-devtools.cjs"
      },
      "production": {
        "module": "./index-node-optimized.js",
        "import": "./wrapper-node-optimized.js",
        "require": "./index-node-optimized.cjs"
      },
      "default": "./wrapper-node-process-env.cjs"
    },
    "development": "./index-with-devtools.js",
    "production": "./index-optimized.js",
    "default": "./index-optimized.js"
  }
}
```

Looks complex, yes. We were already able to reduce some complexity due to a assumption we can make: Only `node` need a CommonJs version and can detect production/development with `process.env`.

## Guidelines

- Avoid the `default` export. It's handled differently between tooling. Only use named exports.
- Never provide different APIs or semantics for different conditions.
- Write your source code as ESM and transpile to CJS via babel, typescript or similar tools.
- Either use `.cjs` or `type: "commonjs"` in package.json to clearly mark source code as CommonJs. This makes it statically detectable for tools if CommonJs or ESM is used. This is important for tools that only support ESM and no CommonJs.
- ESM used in packages support the following types of requests:
  - module requests are supported, pointing to other packages with a package.json.
  - relative requests are supported, pointing to other files within the package.
    - They must not point to files outside of the package.
  - `data:` url requests are supported.
  - other absolute or server-relative requests are not supported by default, but they might be supported by some tools or environments.
